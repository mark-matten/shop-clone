import { v } from "convex/values";
import { action, internalMutation } from "./_generated/server";
import { internal } from "./_generated/api";
import { Id } from "./_generated/dataModel";

// Helper function to convert ArrayBuffer to base64 (works in Convex V8 environment)
function arrayBufferToBase64(buffer: ArrayBuffer): string {
  const bytes = new Uint8Array(buffer);
  let binary = "";
  for (let i = 0; i < bytes.byteLength; i++) {
    binary += String.fromCharCode(bytes[i]);
  }
  return btoa(binary);
}

// Type for closet item with image info
interface ClosetItemWithImage {
  _id: Id<"closet_items">;
  name?: string;
  brand?: string;
  color?: string;
  material?: string;
  category?: string;
  imageStorageId: Id<"_storage"> | null;
  imageUrl: string | null;
}

// Generate a clothing image from description using Gemini 2.5 Flash
export const generateClothingImage = action({
  args: {
    clerkId: v.string(),
    description: v.string(),
    brand: v.optional(v.string()),
    color: v.optional(v.string()),
    material: v.optional(v.string()),
    category: v.string(),
    size: v.optional(v.string()),
  },
  handler: async (ctx, args) => {
    const apiKey = process.env.GOOGLE_GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error("GOOGLE_GEMINI_API_KEY environment variable not set");
    }

    // Build the prompt for clothing image generation
    const promptParts = [
      `Generate a professional product photo of a ${args.category} clothing item.`,
      `Item description: ${args.description}`,
    ];

    if (args.brand) {
      promptParts.push(`Brand style: ${args.brand}`);
    }
    if (args.color) {
      promptParts.push(`Color: ${args.color}`);
    }
    if (args.material) {
      promptParts.push(`Material: ${args.material}`);
    }

    promptParts.push(
      "",
      "Requirements:",
      "- Clean white or light neutral background",
      "- Item laid flat or on an invisible mannequin",
      "- High quality, professional e-commerce photography style",
      "- No human models, just the clothing item itself",
      "- Well-lit with soft shadows",
      "- Item centered in frame"
    );

    const prompt = promptParts.join("\n");

    // Call Nano Banana Pro (Gemini 3 Pro Image) API for image generation
    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent?key=${apiKey}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify({
          contents: [
            {
              parts: [
                {
                  text: prompt,
                },
              ],
            },
          ],
          generationConfig: {
            responseModalities: ["TEXT", "IMAGE"],
            imageConfig: {
              aspectRatio: "1:1",
              imageSize: "1K",
            },
          },
        }),
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error("Gemini API error response:", errorText);
      let errorMessage = `Gemini API error: ${response.status}`;
      try {
        const errorJson = JSON.parse(errorText);
        if (errorJson.error?.message) {
          errorMessage = `Gemini: ${errorJson.error.message}`;
        }
      } catch {
        // Keep the original error message
      }
      throw new Error(errorMessage);
    }

    const result = await response.json();

    // Extract the image data from the response
    const imageData = result.candidates?.[0]?.content?.parts?.find(
      (part: { inlineData?: { mimeType: string; data: string } }) =>
        part.inlineData?.mimeType?.startsWith("image/")
    );

    if (!imageData?.inlineData?.data) {
      console.error("No image in Gemini response");
      throw new Error("No image generated by Gemini");
    }

    // Convert base64 to blob and upload to Convex storage
    const imageBytes = Uint8Array.from(atob(imageData.inlineData.data), (c) =>
      c.charCodeAt(0)
    );
    const blob = new Blob([imageBytes], {
      type: imageData.inlineData.mimeType,
    });

    // Upload to Convex storage
    const storageId = await ctx.storage.store(blob);

    // Create closet item with generated image
    const closetItemId: Id<"closet_items"> = await ctx.runMutation(
      internal.gemini.createGeneratedClosetItem,
      {
        clerkId: args.clerkId,
        name: args.description,
        brand: args.brand,
        color: args.color,
        material: args.material,
        category: args.category,
        size: args.size,
        generatedImageStorageId: storageId,
        userDescription: args.description,
      }
    );

    // Get the image URL
    const imageUrl = await ctx.storage.getUrl(storageId);

    return {
      closetItemId,
      storageId,
      imageUrl,
    };
  },
});

// Internal mutation to create closet item with generated image
export const createGeneratedClosetItem = internalMutation({
  args: {
    clerkId: v.string(),
    name: v.string(),
    brand: v.optional(v.string()),
    color: v.optional(v.string()),
    material: v.optional(v.string()),
    category: v.string(),
    size: v.optional(v.string()),
    generatedImageStorageId: v.id("_storage"),
    userDescription: v.string(),
  },
  handler: async (ctx, args) => {
    // Get or create user
    const user = await ctx.db
      .query("users")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", args.clerkId))
      .first();

    if (!user) {
      throw new Error("User not found");
    }

    // Get next sort order
    const existingItems = await ctx.db
      .query("closet_items")
      .withIndex("by_userId", (q) => q.eq("userId", user._id))
      .collect();

    const maxSortOrder = Math.max(
      0,
      ...existingItems.map((item) => item.sortOrder ?? 0)
    );

    // Create closet item
    return await ctx.db.insert("closet_items", {
      userId: user._id,
      addedAt: Date.now(),
      source: "generated",
      name: args.name,
      brand: args.brand,
      color: args.color,
      material: args.material,
      category: args.category,
      size: args.size,
      generatedImageStorageId: args.generatedImageStorageId,
      userDescription: args.userDescription,
      sortOrder: maxSortOrder + 1,
    });
  },
});

// Generate a virtual try-on image
export const generateTryOnImage = action({
  args: {
    clerkId: v.string(),
    productIds: v.array(v.string()), // Accept string productIds (works for both owned and wishlist)
    userPhotoStorageId: v.optional(v.id("_storage")),
    useGenericModel: v.boolean(),
    gender: v.optional(v.union(v.literal("female"), v.literal("male"))),
  },
  handler: async (ctx, args) => {
    const apiKey = process.env.GOOGLE_GEMINI_API_KEY;
    if (!apiKey) {
      throw new Error("GOOGLE_GEMINI_API_KEY environment variable not set");
    }

    // Fetch products directly by productId
    const items = await Promise.all(
      args.productIds
        .filter((id) => !id.startsWith("url-") && !id.startsWith("gen-")) // Skip non-product items for now
        .map((id) =>
          ctx.runQuery(internal.gemini.getProductWithImage, { productId: id as Id<"products"> })
        )
    );

    const validItems = items.filter((item): item is NonNullable<typeof item> => item !== null);
    if (validItems.length === 0) {
      throw new Error("No valid items provided");
    }

    // Build prompt
    const promptParts: string[] = [];

    // Determine gender for the model (default to female if not specified)
    const modelGender = args.gender || "female";
    const genderDescription = modelGender === "male" ? "male" : "female";

    if (args.userPhotoStorageId && !args.useGenericModel) {
      promptParts.push(
        `Generate a fashion photo of a real ${genderDescription} person wearing an outfit.`,
        "Use the provided reference photo to match the person's appearance, face, and body type exactly.",
        "Show the person's face clearly - this is the user trying on clothes virtually.",
        "IMPORTANT: Use a real human model, NOT a mannequin or faceless figure.",
        ""
      );
    } else {
      promptParts.push(
        `Generate a fashion photo of a real ${genderDescription} model wearing an outfit.`,
        "Use an attractive, professional model with a natural, relaxed pose.",
        "Show the model's face clearly. Style it as a fashion catalog or e-commerce photo.",
        "IMPORTANT: Use a real human model, NOT a mannequin or faceless figure.",
        ""
      );
    }

    promptParts.push("Outfit items:");

    for (const item of validItems) {
      const desc = [item.name];
      if (item.brand) desc.push(`by ${item.brand}`);
      if (item.color) desc.push(`in ${item.color}`);
      if (item.material) desc.push(`made of ${item.material}`);
      promptParts.push(`- ${desc.join(" ")}`);
    }

    promptParts.push(
      "",
      "Style requirements:",
      "- Natural, relaxed pose",
      "- Well-lit, professional fashion photography",
      "- Clean, simple background (studio or minimal setting)",
      "- The clothing items should be clearly visible and recognizable",
      "- High quality, editorial style"
    );

    const textPrompt = promptParts.join("\n");

    // Build the request with images
    const contentParts: Array<
      | { text: string }
      | { inlineData: { mimeType: string; data: string } }
    > = [];

    // Add text prompt
    contentParts.push({ text: textPrompt });

    // Add user photo if provided
    if (args.userPhotoStorageId && !args.useGenericModel) {
      const photoBlob = await ctx.storage.get(args.userPhotoStorageId);
      if (photoBlob) {
        const arrayBuffer = await photoBlob.arrayBuffer();
        const base64 = arrayBufferToBase64(arrayBuffer);
        contentParts.push({
          inlineData: {
            mimeType: photoBlob.type || "image/jpeg",
            data: base64,
          },
        });
        contentParts.push({
          text: "(Above is the reference photo - match this person's appearance, face, and body type exactly.)",
        });
      }
    }

    // Add clothing item images
    for (const item of validItems) {
      const itemWithImage = item as typeof item & { imageStorageId?: Id<"_storage">; imageUrl?: string | null };
      if (itemWithImage.imageStorageId) {
        const itemBlob = await ctx.storage.get(itemWithImage.imageStorageId);
        if (itemBlob) {
          const arrayBuffer = await itemBlob.arrayBuffer();
          const base64 = arrayBufferToBase64(arrayBuffer);
          contentParts.push({
            inlineData: {
              mimeType: itemBlob.type || "image/jpeg",
              data: base64,
            },
          });
          contentParts.push({
            text: `(Above is the ${item.category || "clothing item"}: ${item.name})`,
          });
        }
      } else if (itemWithImage.imageUrl) {
        // If we have a URL but no storage ID, fetch the image
        try {
          const response = await fetch(itemWithImage.imageUrl);
          if (response.ok) {
            const arrayBuffer = await response.arrayBuffer();
            const base64 = arrayBufferToBase64(arrayBuffer);
            const mimeType =
              response.headers.get("content-type") || "image/jpeg";
            contentParts.push({
              inlineData: {
                mimeType,
                data: base64,
              },
            });
            contentParts.push({
              text: `(Above is the ${item.category || "clothing item"}: ${item.name})`,
            });
          }
        } catch (e) {
          console.warn(`Failed to fetch image for item ${item.name}:`, e);
        }
      }
    }

    // Call Nano Banana Pro (Gemini 3 Pro Image) API for outfit generation
    const requestBody = {
      contents: [
        {
          parts: contentParts,
        },
      ],
      generationConfig: {
        responseModalities: ["TEXT", "IMAGE"],
        imageConfig: {
          aspectRatio: "4:3",
          imageSize: "2K",
        },
      },
    };

    console.log("Nano Banana Pro request - items:", validItems.length, "parts:", contentParts.length);

    const response = await fetch(
      `https://generativelanguage.googleapis.com/v1beta/models/gemini-3-pro-image-preview:generateContent?key=${apiKey}`,
      {
        method: "POST",
        headers: {
          "Content-Type": "application/json",
        },
        body: JSON.stringify(requestBody),
      }
    );

    if (!response.ok) {
      const errorText = await response.text();
      console.error("Gemini API error response:", errorText);
      let errorMessage = `Gemini API error: ${response.status}`;
      try {
        const errorJson = JSON.parse(errorText);
        if (errorJson.error?.message) {
          errorMessage = `Gemini: ${errorJson.error.message}`;
        }
      } catch {
        // Keep the original error message
      }
      throw new Error(errorMessage);
    }

    const result = await response.json();
    console.log("Gemini response candidates:", result.candidates?.length);

    // Extract the image data from the response
    const imageData = result.candidates?.[0]?.content?.parts?.find(
      (part: { inlineData?: { mimeType: string; data: string } }) =>
        part.inlineData?.mimeType?.startsWith("image/")
    );

    if (!imageData?.inlineData?.data) {
      // Log what we got back for debugging
      const partTypes = result.candidates?.[0]?.content?.parts?.map(
        (p: { text?: string; inlineData?: unknown }) => p.text ? "text" : p.inlineData ? "inlineData" : "unknown"
      );
      console.error("No image in response. Part types:", partTypes);
      throw new Error("No image generated by Gemini. The model may not support image generation for this request.");
    }

    // Upload to storage
    const imageBytes = Uint8Array.from(atob(imageData.inlineData.data), (c) =>
      c.charCodeAt(0)
    );
    const blob = new Blob([imageBytes], {
      type: imageData.inlineData.mimeType,
    });
    const storageId = await ctx.storage.store(blob);

    // Save outfit image record
    const userPhotoIdResult = args.userPhotoStorageId
      ? await ctx.runQuery(internal.gemini.getUserPhotoIdByStorageId, {
          clerkId: args.clerkId,
          storageId: args.userPhotoStorageId,
        })
      : undefined;
    const userPhotoId: Id<"user_photos"> | undefined = userPhotoIdResult ?? undefined;

    const outfitId: Id<"outfit_images"> = await ctx.runMutation(internal.gemini.saveOutfitRecord, {
      clerkId: args.clerkId,
      storageId,
      closetItemIds: [], // No longer tracking closet item IDs since we use productIds now
      userPhotoId,
      prompt: textPrompt,
    });

    const imageUrl = await ctx.storage.getUrl(storageId);

    return {
      outfitId,
      storageId,
      imageUrl,
    };
  },
});

// Internal query to get closet item with image info
import { internalQuery } from "./_generated/server";

export const getClosetItemWithImage = internalQuery({
  args: { itemId: v.id("closet_items") },
  handler: async (ctx, args) => {
    const item = await ctx.db.get(args.itemId);
    if (!item) return null;

    // For generated items, use the generated image storage ID
    if (item.source === "generated" && item.generatedImageStorageId) {
      return {
        ...item,
        imageStorageId: item.generatedImageStorageId,
        imageUrl: await ctx.storage.getUrl(item.generatedImageStorageId),
      };
    }

    // For URL-sourced or product-linked items, use the imageUrl
    if (item.imageUrl) {
      return {
        ...item,
        imageStorageId: null,
        imageUrl: item.imageUrl,
      };
    }

    // For product-linked items, get image from the product
    if (item.productId) {
      const product = await ctx.db.get(item.productId);
      if (product) {
        return {
          ...item,
          name: item.name ?? product.name,
          brand: item.brand ?? product.brand,
          category: item.category ?? item.customCategory ?? product.category,
          imageStorageId: null,
          imageUrl: product.imageUrl,
        };
      }
    }

    return item;
  },
});

// Internal query to get product details by productId (for wishlist items)
export const getProductWithImage = internalQuery({
  args: { productId: v.id("products") },
  handler: async (ctx, args) => {
    const product = await ctx.db.get(args.productId);
    if (!product) return null;

    return {
      name: product.name,
      brand: product.brand,
      category: product.category,
      color: product.colorName,
      material: product.material,
      imageStorageId: undefined as Id<"_storage"> | undefined,
      imageUrl: product.imageUrl,
    };
  },
});

// Internal query to get user photo ID by storage ID
export const getUserPhotoIdByStorageId = internalQuery({
  args: {
    clerkId: v.string(),
    storageId: v.id("_storage"),
  },
  handler: async (ctx, args) => {
    const photo = await ctx.db
      .query("user_photos")
      .withIndex("by_clerkId", (q) => q.eq("clerkId", args.clerkId))
      .filter((q) => q.eq(q.field("storageId"), args.storageId))
      .first();

    return photo?._id;
  },
});

// Internal mutation to save outfit record
export const saveOutfitRecord = internalMutation({
  args: {
    clerkId: v.string(),
    storageId: v.id("_storage"),
    closetItemIds: v.array(v.id("closet_items")),
    userPhotoId: v.optional(v.id("user_photos")),
    prompt: v.string(),
  },
  handler: async (ctx, args) => {
    return await ctx.db.insert("outfit_images", {
      clerkId: args.clerkId,
      storageId: args.storageId,
      closetItemIds: args.closetItemIds,
      userPhotoId: args.userPhotoId,
      generatedAt: Date.now(),
      prompt: args.prompt,
    });
  },
});
